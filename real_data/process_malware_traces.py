#!/usr/bin/env python3
"""
Process large Malware-Traces folder and produce a flattened TSV dataset file:

data/processed/dataset_raw.tsv  (format: id \t label \t flattened_trace)

Label rule: if the trace contains the substring "C:\\pin\\malware.exe" -> label=1 (malware)
Otherwise label=0 (benign)

This script supports:
- zipped input: Malware-Traces/gw.zip, Malware-Traces/mw.zip
- extracted input: Malware-Traces/gw_results/, Malware-Traces/mw_results/
"""
import os
import io
import sys
import argparse
import random
from zipfile import ZipFile
from pathlib import Path
import re

def flatten_trace_text(text):
    """
    Lightweight flattening for sandbox logs:
    - keep only lines that are non-empty
    - remove timestamps if present
    - replace sequences of whitespace with a single space
    - remove binary paths user might want to anonymize (optional)
    Return a single short string of tokens.
    If you prefer the repo's to_text/normalizers logic, replace this function call
    with the appropriate function import from your repo.
    """
    lines = []
    for raw in text.splitlines():
        s = raw.strip()
        if not s:
            continue
        # keep the whole line but remove extra whitespace
        s = re.sub(r"\s+", " ", s)
        # optionally remove very long hex strings or GUIDs (you can adjust these)
        s = re.sub(r"[0-9a-fA-F]{32,}", "<HEX>", s)
        lines.append(s)
    # join with ' ||| ' to keep boundaries visible
    return " ||| ".join(lines[:5000])  # cap length to avoid absurdly long strings

def iter_txt_files_in_zip(zip_path, inner_folder=None):
    with ZipFile(zip_path, "r") as z:
        for name in z.namelist():
            # optionally filter by inner folder names like gw_results/ or mw_results/
            if inner_folder and not name.startswith(inner_folder):
                continue
            if name.lower().endswith(".txt"):
                with z.open(name) as fh:
                    try:
                        txt = fh.read().decode("utf-8", errors="ignore")
                    except Exception:
                        txt = fh.read().decode("latin-1", errors="ignore")
                    yield name, txt

def iter_txt_files_in_folder(folder_path):
    for root, _, files in os.walk(folder_path):
        for f in files:
            if f.lower().endswith(".txt"):
                p = os.path.join(root, f)
                try:
                    with open(p, "r", encoding="utf-8", errors="ignore") as fh:
                        txt = fh.read()
                except Exception:
                    with open(p, "r", encoding="latin-1", errors="ignore") as fh:
                        txt = fh.read()
                yield p, txt

def main():
    ap = argparse.ArgumentParser()
    ap.add_argument("--input_dir", default="Malware-Traces", help="Folder containing gw.zip and mw.zip or extracted folders")
    ap.add_argument("--out", default="data/processed/dataset_raw.tsv")
    ap.add_argument("--max_samples", type=int, default=0, help="0 means no limit per class; >0 limits total samples per class")
    ap.add_argument("--shuffle", action="store_true")
    args = ap.parse_args()

    inp = Path(args.input_dir)
    outp = Path(args.out)
    outp.parent.mkdir(parents=True, exist_ok=True)

    samples = []  # list of tuples (id, label, flat_text)
    sid = 0

    # helper to process (path_or_zip, iterator)
    def process_iter(iterator, source_name):
        nonlocal sid, samples
        for name, txt in iterator:
            label = 1 if "C:\\pin\\malware.exe" in txt or "C:\\pin\\malware.exe".replace("\\","\\") in txt else 0
            flat = flatten_trace_text(txt)
            # small sanity filter
            if len(flat) < 20:
                continue
            samples.append((str(sid), label, flat))
            sid += 1

    # check for gw.zip / mw.zip
    gwzip = inp / "gw.zip"
    mwzip = inp / "mw.zip"
    if gwzip.exists() and mwzip.exists():
        print("Found gw.zip and mw.zip — streaming text files from zips...")
        # try to detect inner folder names starting with gw_results or mw_results; if uncertain, stream all txt
        process_iter(iter_txt_files_in_zip(gwzip), "gw.zip")
        process_iter(iter_txt_files_in_zip(mwzip), "mw.zip")
    else:
        # look for gw_results and mw_results extracted folders
        gwfolder = inp / "gw_results"
        mwfolder = inp / "mw_results"
        if gwfolder.exists() and mwfolder.exists():
            print("Found extracted gw_results and mw_results folders — reading .txt files")
            process_iter(iter_txt_files_in_folder(gwfolder), "gw_results")
            process_iter(iter_txt_files_in_folder(mwfolder), "mw_results")
        else:
            # fallback: scan whole input_dir for txt files
            print("No zip or expected folders found. Scanning entire directory for .txt files")
            process_iter(iter_txt_files_in_folder(inp), "scan")

    # optional limit per class
    if args.max_samples > 0:
        # split by class and pick up to max_samples per class
        byclass = {0: [], 1: []}
        for triple in samples:
            byclass[triple[1]].append(triple)
        samples = []
        for k in [0,1]:
            samples.extend(byclass[k][:args.max_samples])

    if args.shuffle:
        random.shuffle(samples)

    print(f"Writing {len(samples)} samples to {outp}")
    with open(outp, "w", encoding="utf-8") as f:
        for sid, label, flat in samples:
            # format expected by repo: id \t label \t trace
            safe_flat = flat.replace("\n", " ").replace("\r", " ")
            f.write(f"{sid}\t{label}\t{safe_flat}\n")

    print("Done.")

if __name__ == "__main__":
    main()
